# ОТВЕТЫ НА ВОПРОСЫ ДЛЯ САМОПРОВЕРКИ

### 1) В чем состоит различие между понятиями «поток» и «процесс»?
Процесс - это программа в состоянии выполнения, а поток - параллельно выполняющиеся процедуры в рамках одного процесса.

### 2) Как осуществить передачу параметров в функцию потока при создании потока?
Создание потока в стандарте POSIX осуществляется с помощью вызова функции `pthread_create(...)`.<br/>
Функция принимает 4 параметра, последний из которых, `void *arg` - указатель на структуру данных, описывающих передаваемые в поток параметры.<br/>
Шаблон поточной функции:
```c++
    static void * thread_start(void *arg)
```
**Вопрос по методичке** <br/>
Создали тип данных, который хранит аргументы, передаваемые в функцию:
```c++
   typedef struct {...} targs;
```
После этого объявили аргументы, присвоили им значения, передали в потоки во время создания функции. Далее функция принимает параметры в потоке (дословно из методички):
```c++
    void * proc1(void *arg) {
        targs *args = (targs*) arg; // передаваемые параметры приведем к типу targs
```
Я не очень понимаю, в чем разница левой и правой части равенства. Насколько я понимаю, функция создания уже передает в поточную функцию тип targs.
Или это из-за void? Типа функция принимает "хоть что-то", не понимая что, и потом с этим разбирается. Просто я думала это по-другому работает.

### 3) Какие способы завершения потока существуют?
Завершить поток можно двумя способами.
1. С помощью функции `int pthread_cancel(pthread_t thread)` из другого потока;
2. С помощью функции `int pthread_exit(void *value_ptr)` из текущего потока.

В последнем случае появляется возможность через переменную `value_ptr` передать в основной поток "код завершения". При этом необходимо синхронизировать завершение с основным потоком.

Функция `pthread_exit()` вызывается в конце работы потока и выставляет некоторый код завершения в своем параметре. Например, для передачи кода завершения, равного 2:
```c++
    pthread_exit((void*)2)
```
Функция `main()` принимает это число в функции `pthread_join()`. Объявим в `main()` переменную (на примере одного потока):
``` c++
    int *exitcode;
```
Вызываем функцию `pthread_join()`:
```c++
   pthread_join(id, (void**)&exitcode);
```
В конце выводим код завершения на экран.

### 4) На какие характеристики потока можно влиять через атрибуты потока?
Вторым параметром функция создания потока `pthread_create` принимает указатель на объект атрибутов потока. Один и тот же объект может быть использован для запуска нескольких потоков.<br/>
С помощью атрибутов можно влиять на такие значения потока, как:
- `scope` - новый поток не присоединен ни к одному процессу;
- `stackaddr` - адрес стека, выделенного системой;
- `stacksize` - новый поток имеет размер стека, определенного системой;
- `detachstate` - статус выхода, поток может быть сохранен после завершения.<br/>

Последний из них - статус отсоединения потока - представляет наибольший интерес. Поток может быть создан как *ожидаемый* (по умолчанию) или *отсоединенный*. Ожидаемый поток, подобно процессу, после своего завершения не удаляется автоматически операционной системой. Код его завершения хранится где-то в системе, пока какой-нибудь другой поток не вызовет функцию `pthread_join()`, чтобы запросить это значение. Отсоединенный поток, завершившись, сразу уничтожается. Другие потоки не могут вызвать по отношению к нему функцию `pthread_join()` или получить возвращаемое им значение.

### 5) В каких состояниях может находиться поток?
Поток может быть в трех состояниях:
- *Активный* - в процессе выполнения, потоку доступны все ресурсы;
- *Блокированный* - в состоянии ожидания ресурсов;
- *Готовый* - располагает всеми необходимыми ресурсами, кроме процессора.
***(почему-то сомневаюсь в ответе)***

### 6) Какие способы переключения задач используются в ОС?
В ядре многозадачной среды можно выделить два способа переключения задач:
1. *По времени* - с помощью диспетчера;
2. *По событию* - с помощью планировщика.<br/>

Использовать только первый способ переключения задач нерационально, так как некоторые процессы находятся в очередях блокированных процессов, а диспетчер имеет дело только с очередью готовых процессов. Использовать только второй способ также нерационально, так как если процесс не вызывает процедуру планировщика, то очереди не будут пересмотрены и окажется возможным длительный захват процессора одним процессом.

### 7) Объясните суть параметров, входящих в вызов `pthread_create()`.
```c++
    int pthread_create(pthread_t *thread,
                       const pthread_attr_t *attr,
                       void *(*start_routine) (void *),
                       void *arg)
```
Здесь:
- `thread` – указатель на идентификатор потока;
- `attr` – указатель на структуру данных, описывающих атрибуты потока;
- `start_routine` – имя функции, выполняющей роль потока;
- `arg` – указатель на структуру данных, описывающих передаваемые в поток параметры.

### 8) Объясните суть параметров, входящих в вызов `pthread_join()`.
```c++
    pthread_join(pthread_t thread, void **retval)
```
Здесь:
- `thread` - идентификатор потока;
- `void **retval` - результат завершения потока.

### 9) Опишите трассу выполнения программы.
1. Создаем два потока из функций `proc1` и `proc2`, функции начинают параллельно работать (работа основной программы приостанавливливается до нажатия клавиши, потоки продолжают работать);
2. После нажатия клавиши флаги изменяют свои значения, а программа начинает ждать конца выполнения потоков;
3. Первый поток после выполениня последней итерации проверяет флаг и заканчивает свою работу. Функция `pthread_join` сообщает основной программе о завершении первого потока;
4. Второй поток действует аналогично первому;
5. Программа проверяет завершение обоих потоков и прекращает свою работу.
