# ОТВЕТЫ НА ВОПРОСЫ ДЛЯ САМОПРОВЕРКИ

### 1) Как обеспечивается синхронизация записи и чтения в неименованном канале?
Рассмотрим ситуацию, когда *первый* поток *пишет* данные в `pipe`, а *второй* *читает* данные из него.<br/>
Если `pipe` пустой, то есть данные не записаны, то второй (читающий) поток блокируется, пока первый не запишет данные. Если `pipe` полный, то есть данные второй поток не читает, то записывающий поток блокируется, пока второй не прочитает данные и не освободит место под запись новых.

### 2) Как осуществить использование неименованного канала для взаимодействия процессов?
Перед началом работы необходимо создать неименованный канал. Сделать это можно следующим образом:
```c
    int pipe(int filedes[2]);
```
Здесь:
- `filedes[2]` - массив из двух файловых дескрипторов, один из которых используется для записи данных `filedes[1]`, а второй `filedes[0]` - для чтения данных.<br/>

Чтение данных из канала производятся с помощью следующих операций:
```c
    ssize_t read(int fd, void *buf, size_t count);
```
Здесь:
- `fd` - файловый дескриптор для чтения;
- `buf` - адрес буфера для чтения данных;
- `count` - размер буфера.<br/>

Если поток, который вызывает операцию `read()`, попытается прочитать данные из пустого канала, в который ничего не записано, то этот поток заблокируется, то есть после вызова операции в ней и останется.<br/>

Запись данных в канал производится следующей операцией:
```c
    ssize_t write(int fd, const void *buf, size_t count);
```
Здесь:
- `fd` - файловый дескриптор для записи;
- `buf` - адрес буфера для записи данных;
- `count` - количество байтов, предназначенных для записи.<br/>

Если поток, вызывающий операцию `write()`, попытается записать данные в полный канал, из которого никто не читает, то этот поток заблокируется, то есть после вызова операции в ней и останется.<br/>

Каждый из дескрипторов канала необходимо отдельно закрыть следующим вызовом:
```c
    int close(int fd);
```

### 3) Как для неименованного канала организовать чтение и запись данных «без ожидания»?
Операции, рассмотренные в предыдущем вопросе, в случае, если никто не записывает в канал (для `read()`) или никто не читает из канала (для `write()`) **блокируют** поток. Если никто так и не запишет/прочитает данные, потоки так и останутся заблокированными.<br/>

Есть другой способ решения этой задачи - операции чтения и записи в *неблокирующем* режиме. В этом случае операции `read()` и `write()` не зависают при полном или пустом канале, они сразу завершаются после вызова, но возвращают результат.<br/>

Реализовать неблокирующие операции чтения и записи в неименованном канале можно двумя способами.<br/>

1. Функция создания канала
```c
    int pipe2(int pipefd[2], int flags);
```
Здесь в качестве параметра `int flags` необходимо передать значение `O_NONBLOCK`, обеспечивающее неблокируемое состояние операций чтения и записи для созданных дескрипторов.<br/>
2. Функция для установления флагов состояния дескрипторов
```c
    int fcntl(int fd, int cmd, ... /* arg */ );
```
Здесь в качестве параметра `int cmd` можно передать команду `F_SETFL` установки флагов состояния дескриптора, а в списке аргументов можно передать флаг `O_NONBLOCK`. Канал надо открыть вызовом pipe, а затем каждому дескриптору установить флаг. То есть функцию `fcntl` надо вызвать дважды.<br/>

Второй вариант является более универсальным, так как первый существует только в OC Linux.

### 4) Как реализовать функциональность неименованного канала с помощью семафоров?
Так как сначала надо записать данные в ячейку, а потом уже прочитать их, для корректной работы потоки необходимо обеспечить информацией. После записи будет выполняться операция `сообщить` (что записал), а перед чтением, если ничего не записано, операция `ждать`.<br/>

Для семафора определены две важные операции:
- `P-операция (ждать)`. Определяет условие *блокировки* процесса и может быть использована при в ходе в критический участок;
- `V-операция (сообщить)`. Определяет условие *активизации* процесса и может быть использована при выходе из критического участка.<br/>

Важно помнить, что данные операции реализуются с помощью общаего семафора, следовательно, данные операции изменяют значения счетчика.

Будем рассматривать случай, когда критический участок находится в цикле. Тогда может возникнуть ситуация, когда пишуший поток работает быстрее читающего, то есть происходит потеря данных. Для решения этой проблемы необходимо, чтобы количество записей равнялось количеству чтений: операции должны синхронизироваться двумя семафорами<br/>

Выполнить это условие можно следующим образом:
```c
    # Пишущий поток P1
    while (1) {
        ...
        # Запись в ячейку памяти;
        S1.V;
        S2.P;
        ...
    }
```
Поток `P1` записал данные в ячейку, сообщил, что записал, и перешел к ожиданию чтения.
```c
    # Читающий поток P2
    while (1) {
        ....
        S1.P;
        # Чтение из ячейки памяти;
        S2.V;
    }
```
После записи поток `P2` выходит из ожидания, читает данные и вызывает операцию `S2.V`, то есть сообщает, что данные прочитаны. Первый поток в свою очередь выходит из операции `S2.P` и переходит к новой записи.
В этом случае запись и чтение данных полностью синхронизированы: один раз записали, один раз прочитали.

### 5) Как с помощью неименованных каналов организовать двунаправленное взаимодействие?
Необходимо создать два канала.

### 6) Каким отношением должны быть связаны процессы, чтобы взаимодействие между ними могло бы быть организовано через неименованные каналы?
Процессы должны быть связаны отношением ребенок-родитель.
