# ОТВЕТЫ НА ВОПРОСЫ ДЛЯ САМОПРОВЕРКИ

### 1) Как обеспечивается синхронизация записи и чтения в неименованном канале?
Рассмотрим ситуацию, когда *первый* поток *пишет* данные в `pipe`, а *второй* *читает* данные из него.<br/>
Если `pipe` пустой, то есть данные не записаны, то второй (читающий) поток блокируется, пока первый не запишет данные. Если `pipe` полный, то есть данные второй поток не читает, то записывающий поток блокируется, пока второй не прочитает данные и не освободит место под запись новых.

### 2) Как осуществить использование неименованного канала для взаимодействия процессов?
Перед началом работы необходимо создать неименованный канал. Сделать это можно следующим образом:
```c
    int pipe(int filedes[2]);
```
Здесь:
- `filedes[2]` - массив из двух файловых дескрипторов, один из которых используется для записи данных `filedes[1]`, а второй `filedes[0]` - для чтения данных.<br/>

Чтение данных из канала производятся с помощью следующих операций:
```c
    ssize_t read(int fd, void *buf, size_t count);
```
Здесь:
- `fd` - файловый дескриптор для чтения;
- `buf` - адрес буфера для чтения данных;
- `count` - размер буфера.<br/>
Если поток, который вызывает операцию `read()`, попытается прочитать данные из пустого канала, в который ничего не записано, то этот поток заблокируется, то есть после вызова операции в ней и останется.<br/>

Запись данных в канал производится следующей операцией:
```c
    ssize_t write(int fd, const void *buf, size_t count);
```
Здесь:
- `fd` - файловый дескриптор для записи;
- `buf` - адрес буфера для записи данных;
- `count` - количество байтов, предназначенных для записи.<br/>
Если поток, вызывающий операцию `write()`, попытается записать данные в полный канал, из которого никто не читает, то этот поток заблокируется, то есть после вызова операции в ней и останется.<br/>

Каждый из дескрипторов канала необходимо отдельно закрыть следующим вызовом:
```c
    int close(int fd);
```

### 3) Как для неименованного канала организовать чтение и запись данных «без ожидания»?
Операции, рассмотренные в предыдущем вопросе, в случае, если никто не записывает в канал (в случае с `read()`) или никто не читает из канала (в случае с `write()`) **блокируют** поток. Если никто так и не запишет/прочитает данные, потоки так и останутся заблокированными.<br/>

Есть другой способ решения этой задачи - операции чтения и записи в *неблокирующем* режиме. В этом случае операции `read()` и `write()` не зависают при полном или пустом канале, они сразу завершаются после вызова, но возвращают результат.<br/>

Реализовать неблокирующие операции чтения и записи в неименованном канале можно с помощью двух способов.<br/>

1. Функция создания канала
```c
    int pipe2(int pipefd[2], int flags);
```
Здесь в качестве параметра `int flags` необходимо передать значение `O_NONBLOCK`, обеспечивающее неблокируемое состояние операций чтения и записи для созданных дескрипторов.
2. Функция для установления флагов состояния дескрипторов
```c
    int fcntl(int fd, int cmd, ... /* arg */ );
```
Здесь в качестве параметра `int cmd` можно передать команду `F_SETFL` установки флагов состояния дескриптора, а в списке аргументов можно передать флаг `O_NONBLOCK`. Канал надо открыть вызовом pipe, а затем каждому дескриптору установить флаг. То есть функцию `fcntl` надо вызвать дважды.<br/>

Второй вариант является более универсальным, так как первый существует только в OC Linux.

### 4) Как реализовать функциональность неименованного канала с помощью семафоров?

### 5) Как с помощью неименованных каналов организовать двунаправленное взаимодействие?

### 6) Каким отношением должны быть связаны процессы, чтобы взаимодействие между ними могло бы быть организовано через неименованные каналы?

