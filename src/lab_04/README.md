# ОТВЕТЫ НА ВОПРОСЫ ДЛЯ САМОПРОВЕРКИ

### 1) Какие вызовы для создания процессов, кроме вызова fork(), существуют и в чем состоят их особенности по сравнению с вызовом fork()? 
Используемая нами в лабораторной работе функция `fork()` очень медленная и затратная по ресурсам (необходимо создать точную копию процесса, а затем заменить ее на новый процесс).
В качестве решения можно использовать два нижеописанных варианта.

1. `vfork`
Функция, очень похожая на `fork()`, однако со следующим ограничением: поведение функции не определено, если созданный с её помощью процесс совершит хотя бы одно из следующих действий:
- произведёт возврат из функции, в которой был вызван `vfork()`; 
- вызовет любую функцию кроме `_exit()` или `exec*()`; 
- изменит любые данные кроме переменной, в которой хранится возвращаемое функцией `vfork()` значение.

Другими словами, в отличие от `fork()`, `vfork()` не создает копию родительского процесса, а создает разделяемое с родительским процессом адресное пространство до тех пор, пока не будет вызвана функция `_exit` или одна из функций `exec()`.
Родительский процесс на это время останавливает свое выполнение. Отсюда следуют и все ограничения на использование – дочерний процесс не может изменять никакие глобальные переменные или даже общие переменные, разделяемые с родительским процессом.

Подводя итог, свойство этой функции накладывает серьезное ограничение на ее использование и необходимость учитывать следующие особенности:
- родительский процесс и дочерний процесс совместно используют стек, что требует остановки родительского потока;
- вероятность неопределенного поведения.

2. `clone()`
Функция выполняет ту же задачу, что и предыдущие. В отличие от `fork()` эти вызовы позволяют дочернему процессу использовать ресурсы совместно с вызывающим процессом. 
Результат выполнения показанного кода будет таким же, как и при выполнении обычного вызова `fork()`, за исключением того, что адресное пространство, ресурсы файловой системы, дескрипторы файлов и обработчики сигналов останутся общими. 
Флаги, которые передаются в системный вызов `clone()`, помогают указать особенности поведения нового процесса и детализировать, какие ресурсы должны быть общими для родительского и порожденного процессов.

У данной функции, несмотря на кажущуюся складность также есть проблемы, которые мой детский мозг не может осознать. :)   

### 2) В каком случае дочерний процесс может превратиться в процесс-зомби?
Процесс превращается в процесс-зомби в случае, если родительский процесс завершился быстрее дочернего: последний завершился, но не полностью освободил ресурсы.

### 3) Как процесс может узнать, является ли он родительским процессом или дочерним процессом?
Процесс может узнать свой "статус" с помощью вызова `fork()`.
Если процесс возвращает 0, то это дочерний процесс; если результат больше нуля - то родительский; если результат равен -1, то произошла ошибка.

### 4) Каким образом родительский процесс может ждать завершения дочернего процесса и находиться в не заблокированном состоянии?
Для этого можно использовать функцию `waitpid()`, с установленным в последний параметр значением `WNOHANG` (для блокировки - 0).
Результат этой функции показывает, наступило событие или нет.

```c++
   pid_t waitpid(pid_t pid, int *status, int options);
```
Здесь:
- `pid` - идентификатор дочернего процесса, завершение которого ожидается;
- `status` - результат завершения дочернего процесса;
- `options` - режим работы функции.

Ожидание завершения дочернего процесса можно реализовать следующим образом
```c++
   while (waitpid(pid, &status, WNOHANG) == 0) {
      printf("Wait\n");
      sleep(1);
   }
```

### 5) Какой механизм обмена данными применяется между родительским и дочерним процессами?
`надеюсь правильно поняла вопрос`

В случае, когда в качестве дочернего процесса необходимо выполнить внешнюю программу, в коде дочерней программы следует вызвать функцию семейства `exec()`.
Существует несколько разновидностей этой функции, однако основной является `execve()`, остальные отличаются суффиксами и обеспечивают интерфейс к ней. 

```c++
   int execve(const char *pathname, char *const argv [], char *const envp[]);
```
Здесь:
- `pathname` - путь к внешней программе;
- `argv []` - массив указателей на строки, переданные новой программе в качестве аргументов;
- `envp []` - массив строк, передающийся в формате `key=value`, передающиеся новой программе в качестве окружения (массив должен заканчиваться указателем `nullptr`).

В случае успешного выполнения вызова функции семейства `exec()` не возвращают никакого результата; в случае ошибки возвращается -1, а глобальной переменной errno присваивается значение в соответствие с видом ошибки.

### 6) Как можно показать, что изменения данных, происходящие в дочернем процессе, не затрагивают данные родительского процесса?
`не поняла вопрос.. имеется в виду два ифа, в каждом проверяем пид? `