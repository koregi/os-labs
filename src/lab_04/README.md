# ОТВЕТЫ НА ВОПРОСЫ ДЛЯ САМОПРОВЕРКИ

### 1) Какие вызовы для создания процессов, кроме вызова fork(), существуют и в чем состоят их особенности по сравнению с вызовом fork()? 
План капкан:
1. Минусы `fork()`
2. Что такое `vfork()`, почему все еще жив и чем плох
3. `clone()`

### 2) В каком случае дочерний процесс может превратиться в процесс-зомби?
Процесс превращается в процесс-зомби в случае, если родительский процесс завершился быстрее дочернего: последний завершился, но не полностью освободил ресурсы.

### 3) Как процесс может узнать, является ли он родительским процессом или дочерним процессом?
Процесс может узнать свой "статус" с помощью вызова `fork()`.
Если процесс возвращает 0, то это дочерний процесс; если результат больше нуля - то родительский; если результат равен -1, то произошла ошибка.

### 4) Каким образом родительский процесс может ждать завершения дочернего процесса и находиться в не заблокированном состоянии?
Для этого можно использовать функцию `waitpid()`, с установленным в последний параметр значением `WNOHANG` (для блокировки - 0).
Результат этой функции показывает, наступило событие или нет.

```c++
   pid_t waitpid(pid_t pid, int *status, int options);
```
Здесь:
- `pid` - идентификатор дочернего процесса, завершение которого ожидается;
- `status` - результат завершения дочернего процесса;
- `options` - режим работы функции.

Ожидание завершения дочернего процесса можно реализовать следующим образом
```c++
   while (waitpid(pid, &status, WNOHANG) == 0) {
      printf("Wait\n");
      sleep(1);
   }
```

### 5) Какой механизм обмена данными применяется между родительским и дочерним процессами?
`надеюсь правильно поняла вопрос`

В случае, когда в качестве дочернего процесса необходимо выполнить внешнюю программу, в коде дочерней программы следует вызвать функцию семейства `exec()`.
Существует несколько разновидностей этой функции, однако основной является `execve()`, остальные отличаются суффиксами и обеспечивают интерфейс к ней. 

```c++
   int execve(const char *pathname, char *const argv [], char *const envp[]);
```
Здесь:
- `pathname` - путь к внешней программе;
- `argv []` - массив указателей на строки, переданные новой программе в качестве аргументов;
- `envp []` - массив строк, передающийся в формате `key=value`, передающиеся новой программе в качестве окружения (массив должен заканчиваться указателем `nullptr`).

В случае успешного выполнения вызова функции семейства `exec()` не возвращают никакого результата; в случае ошибки возвращается -1, а глобальной переменной errno присваивается значение в соответствие с видом ошибки.

### 6) Как можно показать, что изменения данных, происходящие в дочернем процессе, не затрагивают данные родительского процесса?
`не поняла вопрос.. имеется в виду два ифа, в каждом проверяем пид? `